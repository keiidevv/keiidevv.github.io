---
title: SpringCamp | 켄트 벡의 Tidy First?
author: serin
date: 2024-09-27 18:15:00 +0900
categories: [Seminar, SpringCamp]
tags: [SpringCamp, Architecture]
image:
  path: /assets/img/Seminar/2024/09/27/main.png
  alt: main
---

## 🛠️ [더 나은 소프트웨어 설계를 위한 32가지 코드 정리법](https://youtu.be/IF9Uv5ceB1Q?si=1teetyxTlf6ICmPf)

### Part 1. 15가지 코드 정리법
실제 코드에 직접 적용하며 익히는 것을 권장한다. 해당 파트에서는 보호 구문, 안쓰는 코드, 대칭으로 맞추기 등등 다양한 정리법이 나와 있다.

1. Bottom-up
   1. 켄트 벡이 선호하는 방식이다.
2. 아기 발걸음
   1. 아기들이 자연스럽게 다리 사이에 들어와서 걷는 법을 배운다. 이것은 자연스러운 학습의 모양새이다.
   2. 한 단계, 한 단계씩 나아가는 것!
3. Man in the mirror
   1. 이 표현은 설계 자체는 인간 관계 활동이라고 정의하며 나온다.
   2. 인간 관계 조차도 나부터 설득해야 한다. 다음 책의 제목은 Tidy Together 라고 정의하는데, 타인을 설득하기 위해서 나부터 시작하는 것!
   3. 코드를 변경할 때 쓰는 사람 입장에서, 읽는 사람 입장에서 나 스스로부터 다양하게 생각해볼 수 있다. (다른 사람과 하면 복잡하지만, 나와는 수월하다.)
4. 리팩토링과의 차이
   1. 코드 정리와 리팩터링은 모양, 행위는 같으나 의미, 목적은 다르다.
   2. 코드 정리는 인간 관계 활동이다. 코드 자체의 문제가 아니라 개발자로서의 삶을 보내는 방식에 대한 것이다.

> 코드 정리를 통해 코드를 유기체로 다루는 법을 익힐 수 있다.
{: .prompt-tip}
인간 관계를 잘하는 개발자로 나아가면 나아갈 수록, 실력도 코드와 함께 진화할 수 있다. 단순히 개발을 잘한다는 것이 아니라, 기능 개발과 함께 사람들이 이해를 잘 할 수 있는 능력을 기를 수 있다. 이와 같이 기본이 잡혀 있어야 하므로 해당 책은 2,3부만 보는 것이 아니라, 1부부터 보는 것을 적극 추천한다.

![example1](/assets/img/Seminar/2024/09/27/example1.png){: .w-75 .normal}

### Part 2. 관리
코드 정리는 생각해보면 필수는 아니다. 코드 정리를 어떻게 나를 위해서 혹은 내가 짠 코드를 위해서 관리할 것인가?에 대한 내용이다.

#### 코드 쪼개기
![example2](/assets/img/Seminar/2024/09/27/example2.png){: .w-75 .normal}
여기서 B는 Behavior chanege로 겉으로 드러나는 기능 변경 건이고, S는 Structure로 설계에 관한 작업이다.  
작업하는 것이 기능을 개발하는 건인지, 설계를 위한 건인지에 대한 구분이 일어난다. 통합하고 배포할 때, 모두 합쳐서 전송하는 것이 아니라 호흡을 나눠서 끊어서 처리하는 것이 나중에 기록하거나 팀에 코드를 쉐어할 때에 알려주기 적합하다.

#### 손이 가게 하기
프링글스처럼 자꾸 손이 가게 하려면  
- 이왕이면 더 작게해서, 더 자주 즐기기
- 작은 단계로 두어서, 다음 수를 내다보기

![example3](/assets/img/Seminar/2024/09/27/example3.png){: .w-75 .normal}
급하게 고치는 것보다 이해가 가도록 스텝을 밟아가야 나아가기 편하다. 한꺼번에 묶어서 통합하는 것보다 하나씩 나눠서 통합하는 것의 차이는 크다.  
일괄 처리 규모가 줄수록 검토 비용과 코드 정리 비용이 함께 줄어든다.

- 소프트웨어 설계는
  - **Fractal** -> 작게, 크게 모두 가능하지만, 작고 빈번하게 할수록 유리하다.
  - **길을 닦는 일** -> 쓰임새를 지켜보며 지속해야 하는 일, 실제 쓰이는 것을 보고 개발에 안영할 수 있다.
- 실타래를 풀려면 실이 엉켜 있다는 사실을 알아차려야 시작할 수 있다.
  - 정말 어려운 일은 실이 엉킨 것을 알아채는 것이다.
  - 굉장히 많은 사람들은 해당 코드가 괜찮다고 느낀다. 인식의 문제는 중요한 것이다.

#### 코드 정리 시점
> 언제 할 것인가? 제목에 ?가 있는 이유
{: .prompt-tip}

- 아예 안할 수도 있다.
- 나중에 정리할 수도 있다. 백로드에 넣어 두기.
- 동작 변경 후에 코드를 정리할 수 있다.
  - 잊어버리기 전에 정리한다. 코드 정리가 1시간이 넘어간다면 코드 정리가 아니다.
- 코드 정리 후에 동작을 변경할 수 있다.
  - Tidy First 에서 제안하는 가장 이상적인 방법
  - 잘 차려진 코드에서 일하는 것이 더 좋을 것이라 가정

### Part 3. 이론
배경 지식에 따라 난이도가 갈릴 수 있다. 소프트웨어 설계에 대한 법칙의 기조가 담겨 있다.

#### 요소들을 유익하게 관계 맺는 일
시스템 > 객체/모듈 > 함수 > 문 > 식 > 토큰  
이 요소들이 모두 관계를 맺고 유익하게 설계가 되어야 한다.

설계자가 할 일은 아주 단순하다.  
- 요소를 만들고 삭제하기
- 관계를 만들고 삭제하기
- 관계의 이점을 높이기

하지만, 유익하게 다층으로 이루어지기 위해서는 다양한 양상으로 진행이 되어야 한다. 

소프트웨어는 **두 가지 방식**으로 가치를 만든다.  
1. 현재 소프트웨어가 하는 일
   1. 현재 가치를 생산하는 일이란? 눈에 보이는 것을 바꾸는 것이다.
   2. 사용자의 요구사항이든, 기획자의 기획이든 출시가 바로 현재의 가치를 증명하는 일이다.
2. 미래에 새로운 일을 시킬 수 있는 가능성
   1. = 구조를 바꾸는 일은 관계를 유익하게 맺는 것
   2. 미래의 가치를 어떻게 계산할까? by. 생존 부등식
   3. 코드 정리는 가역성을 비용으로 표현한다.

#### 결합도
결합도의 특성은 두 가지가 있다.  
- 일대다
  - 일대일이 아닌 다양한 것들과 관계를 맺는다.
- 연쇄 작용

### 결론
켄트 벡은 아침에 내 할 일을 떠올리고, 바로 적용해보고, 저녁에 맛을 맛보는 사이클을 추천한다.  
발표자인 안영회님의 설계 덕후로서의 감상은 요소들과 관계를 맺는 일을 유기체처럼 구성하는 것들이코드 레벨에서 말을 하니 굉장히 유익하게 다가왔다.  
따로도 잘 동작하고, 같이도 잘 동작하게!  
사실상 따로 또 같이를 구현하는 다양한 프로그래밍 기법은 많다. DI, RESTful API, MSA, BFF 모두 유기체성으로 같은 원리를 가지고 있다.  
내 코드의 경계를 만들고 잘 유기적으로 소통할 수 있게 할 것인가가 정해질 것이다.  

> *소프트웨어 설계는 프랙탈이므로 설계는 크게도 작동할 수 있다.*  
> *사람마다 다르게 인지한다.*  
